<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PAN Flight Code: Devices::I2CDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PAN Flight Code
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_devices.html">Devices</a></li><li class="navelem"><a class="el" href="class_devices_1_1_i2_c_device.html">I2CDevice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_devices_1_1_i2_c_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Devices::I2CDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class from which all i2c device drivers will be derived.  
 <a href="class_devices_1_1_i2_c_device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i2_c_device_8hpp_source.html">I2CDevice.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Devices::I2CDevice:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_devices_1_1_i2_c_device.png" usemap="#Devices::I2CDevice_map" alt=""/>
  <map id="Devices::I2CDevice_map" name="Devices::I2CDevice_map">
<area href="class_devices_1_1_device.html" title="Interface from which all peripherial devices will be derived. " alt="Devices::Device" shape="rect" coords="66,0,189,24"/>
<area href="class_a_d_s1015.html" alt="ADS1015" shape="rect" coords="0,112,123,136"/>
<area href="class_devices_1_1_gomspace.html" alt="Devices::Gomspace" shape="rect" coords="133,112,256,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3798b32d253b3e30f75e648d7b390a49"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a3798b32d253b3e30f75e648d7b390a49">setup</a> () override</td></tr>
<tr class="memdesc:a3798b32d253b3e30f75e648d7b390a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to initialize communication with the i2c device.  <a href="#a3798b32d253b3e30f75e648d7b390a49">More...</a><br /></td></tr>
<tr class="separator:a3798b32d253b3e30f75e648d7b390a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb87401c706fe75b7c8c4ad5154b69"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a15eb87401c706fe75b7c8c4ad5154b69">is_functional</a> () const override</td></tr>
<tr class="memdesc:a15eb87401c706fe75b7c8c4ad5154b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the device is responding to communications.  <a href="#a15eb87401c706fe75b7c8c4ad5154b69">More...</a><br /></td></tr>
<tr class="separator:a15eb87401c706fe75b7c8c4ad5154b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f49c62499886a4b46b9865f9469be7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a73f49c62499886a4b46b9865f9469be7">reset</a> () override</td></tr>
<tr class="memdesc:a73f49c62499886a4b46b9865f9469be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces this i2c device to be marked as functional.  <a href="#a73f49c62499886a4b46b9865f9469be7">More...</a><br /></td></tr>
<tr class="separator:a73f49c62499886a4b46b9865f9469be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721bdb1057d279a3decb84ea83cc7e98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a721bdb1057d279a3decb84ea83cc7e98">disable</a> () override</td></tr>
<tr class="memdesc:a721bdb1057d279a3decb84ea83cc7e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces this i2c device to be marked as not functional.  <a href="#a721bdb1057d279a3decb84ea83cc7e98">More...</a><br /></td></tr>
<tr class="separator:a721bdb1057d279a3decb84ea83cc7e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5c39d6bdfcd2137cd8a1acd5db9da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a5b5c39d6bdfcd2137cd8a1acd5db9da2">i2c_set_timeout</a> (unsigned long i2c_timeout)</td></tr>
<tr class="memdesc:a5b5c39d6bdfcd2137cd8a1acd5db9da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this device's i2c timeout in milliseconds.  <a href="#a5b5c39d6bdfcd2137cd8a1acd5db9da2">More...</a><br /></td></tr>
<tr class="separator:a5b5c39d6bdfcd2137cd8a1acd5db9da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864269a8f95ea93bc6e69e4d1b28a3ef"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a864269a8f95ea93bc6e69e4d1b28a3ef">i2c_get_timeout</a> () const</td></tr>
<tr class="memdesc:a864269a8f95ea93bc6e69e4d1b28a3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current value of i2c_timeout in milliseconds.  <a href="#a864269a8f95ea93bc6e69e4d1b28a3ef">More...</a><br /></td></tr>
<tr class="separator:a864269a8f95ea93bc6e69e4d1b28a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5615a0f7eef532420a8c534f5f16bc8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a5615a0f7eef532420a8c534f5f16bc8b">i2c_data_is_valid</a> () const</td></tr>
<tr class="memdesc:a5615a0f7eef532420a8c534f5f16bc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the most recent i2c data should be considered valid.  <a href="#a5615a0f7eef532420a8c534f5f16bc8b">More...</a><br /></td></tr>
<tr class="separator:a5615a0f7eef532420a8c534f5f16bc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e06d8a4319e9f7fca03f4969bfe922"><td class="memTemplParams" colspan="2"><a id="a78e06d8a4319e9f7fca03f4969bfe922"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78e06d8a4319e9f7fca03f4969bfe922"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>i2c_transmit_data</b> (T const *data, std::size_t len, i2c_stop s)</td></tr>
<tr class="separator:a78e06d8a4319e9f7fca03f4969bfe922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c1e5af47f3e1663b3859689785abac"><td class="memTemplParams" colspan="2"><a id="a21c1e5af47f3e1663b3859689785abac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21c1e5af47f3e1663b3859689785abac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>i2c_receive_data</b> (T *data, std::size_t len, i2c_stop s)</td></tr>
<tr class="separator:a21c1e5af47f3e1663b3859689785abac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memTemplParams" colspan="2"><a id="acc0c0dec51d0a4e584adaecadd69b2fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>i2c_write</b> (T const *data, std::size_t len)</td></tr>
<tr class="separator:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa55cfbcb2fa942d58c46995218709b7"><td class="memTemplParams" colspan="2"><a id="afa55cfbcb2fa942d58c46995218709b7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa55cfbcb2fa942d58c46995218709b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>i2c_read</b> (T *data, std::size_t len)</td></tr>
<tr class="separator:afa55cfbcb2fa942d58c46995218709b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_devices_1_1_device"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_devices_1_1_device')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_devices_1_1_device.html">Devices::Device</a></td></tr>
<tr class="memitem:a1542d2e343cd737413f977ba98adcdfe inherit pub_methods_class_devices_1_1_device"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_device.html#a1542d2e343cd737413f977ba98adcdfe">single_comp_test</a> ()</td></tr>
<tr class="memdesc:a1542d2e343cd737413f977ba98adcdfe inherit pub_methods_class_devices_1_1_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the device's single component test. This test writes a csv formatted line over Serial. See the actual function implementation for more details.  <a href="class_devices_1_1_device.html#a1542d2e343cd737413f977ba98adcdfe">More...</a><br /></td></tr>
<tr class="separator:a1542d2e343cd737413f977ba98adcdfe inherit pub_methods_class_devices_1_1_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1eb5d89d5d6e8a27f1b63b8a8fdd285c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a1eb5d89d5d6e8a27f1b63b8a8fdd285c">i2c_ping</a> ()</td></tr>
<tr class="memdesc:a1eb5d89d5d6e8a27f1b63b8a8fdd285c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a simple communication with the i2c device - e.g. reading a register with a known value. Returns true if the proper value is recieved. i2c related errors are queried in setup.  <a href="#a1eb5d89d5d6e8a27f1b63b8a8fdd285c">More...</a><br /></td></tr>
<tr class="separator:a1eb5d89d5d6e8a27f1b63b8a8fdd285c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a8099d6f4741ecaa5ce7ee31312b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a4d3a8099d6f4741ecaa5ce7ee31312b0">I2CDevice</a> (i2c_t3 &amp;wire, uint8_t addr, unsigned long timeout=0)</td></tr>
<tr class="memdesc:a4d3a8099d6f4741ecaa5ce7ee31312b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new i2c device object.  <a href="#a4d3a8099d6f4741ecaa5ce7ee31312b0">More...</a><br /></td></tr>
<tr class="separator:a4d3a8099d6f4741ecaa5ce7ee31312b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2864b2e90683c0ae9384219ab457090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#aa2864b2e90683c0ae9384219ab457090">i2c_pop_errors</a> ()</td></tr>
<tr class="memdesc:aa2864b2e90683c0ae9384219ab457090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an error has occurred since the last call to pop_errors and false otherwise. The recent error history variable is reset and the consecutive communication failure variables is incremented if needed.  <a href="#aa2864b2e90683c0ae9384219ab457090">More...</a><br /></td></tr>
<tr class="separator:aa2864b2e90683c0ae9384219ab457090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aae538360ead45a66e08792350b03a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#ac1aae538360ead45a66e08792350b03a">i2c_peek_errors</a> () const</td></tr>
<tr class="memdesc:ac1aae538360ead45a66e08792350b03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical functionality to pop_errors except the recent error history variable isn't reset and the consecutive communication failure variable isn't incrememnted.  <a href="#ac1aae538360ead45a66e08792350b03a">More...</a><br /></td></tr>
<tr class="separator:ac1aae538360ead45a66e08792350b03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c53f774f00a69a7619a6c095e5ffb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1c53f774f00a69a7619a6c095e5ffb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#aa1c53f774f00a69a7619a6c095e5ffb0">i2c_transmit_data</a> (T const *data, std::size_t len, i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:aa1c53f774f00a69a7619a6c095e5ffb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message over i2c to this i2c device.  <a href="#aa1c53f774f00a69a7619a6c095e5ffb0">More...</a><br /></td></tr>
<tr class="separator:aa1c53f774f00a69a7619a6c095e5ffb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed45e8e4066e779b51b78d7ea0d51430"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed45e8e4066e779b51b78d7ea0d51430"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#aed45e8e4066e779b51b78d7ea0d51430">i2c_receive_data</a> (T *data, std::size_t len, i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:aed45e8e4066e779b51b78d7ea0d51430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests and recieves a message over i2c from this i2c device.  <a href="#aed45e8e4066e779b51b78d7ea0d51430">More...</a><br /></td></tr>
<tr class="separator:aed45e8e4066e779b51b78d7ea0d51430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57665922549a629e6a18a56a43d68906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a57665922549a629e6a18a56a43d68906">i2c_begin_transmission</a> ()</td></tr>
<tr class="memdesc:a57665922549a629e6a18a56a43d68906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.beginTransmission in i2c_t3.  <a href="#a57665922549a629e6a18a56a43d68906">More...</a><br /></td></tr>
<tr class="separator:a57665922549a629e6a18a56a43d68906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada09cd5adeea3fa7584f8641f2762374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#ada09cd5adeea3fa7584f8641f2762374">i2c_end_transmission</a> (i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:ada09cd5adeea3fa7584f8641f2762374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.endTransmission from i2c_t3.  <a href="#ada09cd5adeea3fa7584f8641f2762374">More...</a><br /></td></tr>
<tr class="separator:ada09cd5adeea3fa7584f8641f2762374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995510c34057de5825240532e3056cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#ae995510c34057de5825240532e3056cc">i2c_send_transmission</a> (i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:ae995510c34057de5825240532e3056cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.sendTransmission from i2c_t3.  <a href="#ae995510c34057de5825240532e3056cc">More...</a><br /></td></tr>
<tr class="separator:ae995510c34057de5825240532e3056cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7018b892a9075c3e5994634f8775f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#aa7018b892a9075c3e5994634f8775f71">i2c_request_from</a> (std::size_t len, i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:aa7018b892a9075c3e5994634f8775f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.requestFrom in i2c_t3.  <a href="#aa7018b892a9075c3e5994634f8775f71">More...</a><br /></td></tr>
<tr class="separator:aa7018b892a9075c3e5994634f8775f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e1fa9d03718b04326c6fe32a2340d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#ab4e1fa9d03718b04326c6fe32a2340d9">i2c_send_request</a> (std::size_t len, i2c_stop s=I2C_STOP)</td></tr>
<tr class="memdesc:ab4e1fa9d03718b04326c6fe32a2340d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See Wire.sendRequest in i2c_t3. Any error will be recorded in the recent error history variable.  <a href="#ab4e1fa9d03718b04326c6fe32a2340d9">More...</a><br /></td></tr>
<tr class="separator:ab4e1fa9d03718b04326c6fe32a2340d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a282d0abeccc9a239ccb2771396fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a54a282d0abeccc9a239ccb2771396fe7">i2c_done</a> () const</td></tr>
<tr class="memdesc:a54a282d0abeccc9a239ccb2771396fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.done from i2c_t3.  <a href="#a54a282d0abeccc9a239ccb2771396fe7">More...</a><br /></td></tr>
<tr class="separator:a54a282d0abeccc9a239ccb2771396fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30beb28525cd554d554464a3d549dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#a4b30beb28525cd554d554464a3d549dc">i2c_finish</a> ()</td></tr>
<tr class="memdesc:a4b30beb28525cd554d554464a3d549dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined call to Wire.finish from i2c_t3.  <a href="#a4b30beb28525cd554d554464a3d549dc">More...</a><br /></td></tr>
<tr class="separator:a4b30beb28525cd554d554464a3d549dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab012e2a96de88a49060fdf33c01706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#acab012e2a96de88a49060fdf33c01706">i2c_write</a> (uint8_t data)</td></tr>
<tr class="memdesc:acab012e2a96de88a49060fdf33c01706"><td class="mdescLeft">&#160;</td><td class="mdescRight">See Wire.write in i2c_t3. Any error will be recorded in the recent error history variable.  <a href="#acab012e2a96de88a49060fdf33c01706">More...</a><br /></td></tr>
<tr class="separator:acab012e2a96de88a49060fdf33c01706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#acc0c0dec51d0a4e584adaecadd69b2fd">i2c_write</a> (T const *data, std::size_t len)</td></tr>
<tr class="memdesc:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type templated inlined call to Wire.write from i2c_t3.  <a href="#acc0c0dec51d0a4e584adaecadd69b2fd">More...</a><br /></td></tr>
<tr class="separator:acc0c0dec51d0a4e584adaecadd69b2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5fb9b7c3eb25d9e009895814618f81"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#aad5fb9b7c3eb25d9e009895814618f81">i2c_read</a> ()</td></tr>
<tr class="memdesc:aad5fb9b7c3eb25d9e009895814618f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">See Wire.readByte in i2c_t3. Any error will be recorded in the recent error history variable.  <a href="#aad5fb9b7c3eb25d9e009895814618f81">More...</a><br /></td></tr>
<tr class="separator:aad5fb9b7c3eb25d9e009895814618f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa55cfbcb2fa942d58c46995218709b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa55cfbcb2fa942d58c46995218709b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_devices_1_1_i2_c_device.html#afa55cfbcb2fa942d58c46995218709b7">i2c_read</a> (T *data, std::size_t len)</td></tr>
<tr class="memdesc:afa55cfbcb2fa942d58c46995218709b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data type tmeplated inlined call to Wire.read from i2c_t3.  <a href="#afa55cfbcb2fa942d58c46995218709b7">More...</a><br /></td></tr>
<tr class="separator:afa55cfbcb2fa942d58c46995218709b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class from which all i2c device drivers will be derived. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_devices_1_1_i2_c_device.html" title="Abstract class from which all i2c device drivers will be derived. ">I2CDevice</a> class is intended as an abstract class form which all i2c devices will be derived. </dd></dl>
<dl class="section user"><dt></dt><dd>It provides per device i2c fucntionality as opposed to per bus making code and device managment much simpler. Each device specifically has it's own timeout value in milliseconds, i2c bus address, i2c bus reference, and error history state variables. </dd></dl>
<dl class="section user"><dt></dt><dd>The class also wraps common i2c_t3 wire function calls to manage the device device specific variables (error tracking, device specific timeouts, etc.). See <a href="https://github.com/nox771/i2c_t3">https://github.com/nox771/i2c_t3</a> for more information about the teensy i2c library. </dd></dl>
<dl class="section user"><dt></dt><dd>The error history state variables operate in the following manner. Each device has two variables tracking errors. One tracks recent history and is a boolean that holds true if an error has occurred since the last call to <a class="el" href="class_devices_1_1_i2_c_device.html#aa2864b2e90683c0ae9384219ab457090" title="Returns true if an error has occurred since the last call to pop_errors and false otherwise...">i2c_pop_errors()</a> and holds false otherwise. The second variable counts consecutive communication failures with the device and is updated with a call to <a class="el" href="class_devices_1_1_i2_c_device.html#aa2864b2e90683c0ae9384219ab457090" title="Returns true if an error has occurred since the last call to pop_errors and false otherwise...">i2c_pop_errors()</a>. i2c_pop_errors should therefore only be called once during a communication with an i2c device (this includes configuration, requesting, and recieving that is needed to obtain data). Otherwise, <a class="el" href="class_devices_1_1_i2_c_device.html#ac1aae538360ead45a66e08792350b03a" title="Identical functionality to pop_errors except the recent error history variable isn&#39;t reset and the co...">i2c_peek_errors()</a> can be used to check the recent history of i2c errors. </dd></dl>
<dl class="section user"><dt></dt><dd>For consistency, all member functions of this class are prefixed with i2c_. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4d3a8099d6f4741ecaa5ce7ee31312b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3a8099d6f4741ecaa5ce7ee31312b0">&#9670;&nbsp;</a></span>I2CDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">I2CDevice::I2CDevice </td>
          <td>(</td>
          <td class="paramtype">i2c_t3 &amp;&#160;</td>
          <td class="paramname"><em>wire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new i2c device object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wire</td><td>Reference to the Wire this i2c device is on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address byte of this i2c device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout value fro this i2c device in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a721bdb1057d279a3decb84ea83cc7e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721bdb1057d279a3decb84ea83cc7e98">&#9670;&nbsp;</a></span>disable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDevice::disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces this i2c device to be marked as not functional. </p>
<p>The error history variable is set to I2CDEVICE_DISABLE_AT which causes the i2c device to be seen as not functional. This can be reversed by calling the reset function. </p>

<p>Implements <a class="el" href="class_devices_1_1_device.html#a86358d0bb8803606ef022ccd8ffc9521">Devices::Device</a>.</p>

<p>Reimplemented in <a class="el" href="class_devices_1_1_gomspace.html#a97f43bc9ad40a112006a22bbc06ba728">Devices::Gomspace</a>.</p>

</div>
</div>
<a id="a57665922549a629e6a18a56a43d68906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57665922549a629e6a18a56a43d68906">&#9670;&nbsp;</a></span>i2c_begin_transmission()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_begin_transmission </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.beginTransmission in i2c_t3. </p>
<p>The i2c device's address is passed as an argument to the call to Wire.beingTransmission. </p>

</div>
</div>
<a id="a5615a0f7eef532420a8c534f5f16bc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5615a0f7eef532420a8c534f5f16bc8b">&#9670;&nbsp;</a></span>i2c_data_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Devices::I2CDEVICE_V1::I2CDevice::i2c_data_is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the most recent i2c data should be considered valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the most recent data is valid and false otherwise.</dd></dl>
<p>The data is considered valid if the error history variable currently has a value of zero - i.e. the last i2c communication did not result in an error. </p>

</div>
</div>
<a id="a54a282d0abeccc9a239ccb2771396fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a282d0abeccc9a239ccb2771396fe7">&#9670;&nbsp;</a></span>i2c_done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Devices::I2CDEVICE_V1::I2CDevice::i2c_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.done from i2c_t3. </p>
<dl class="section return"><dt>Returns</dt><dd>false if a non-blockign call is still running and true otherwise. </dd></dl>

</div>
</div>
<a id="ada09cd5adeea3fa7584f8641f2762374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada09cd5adeea3fa7584f8641f2762374">&#9670;&nbsp;</a></span>i2c_end_transmission()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_end_transmission </td>
          <td>(</td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.endTransmission from i2c_t3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>The provided or default i2c stop flag as well as this i2c devices timeout value are passed to Wire.endTransmission. Errors reported by Wire.endTransmission are recorded in the recent error history variable. </p>

</div>
</div>
<a id="a4b30beb28525cd554d554464a3d549dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b30beb28525cd554d554464a3d549dc">&#9670;&nbsp;</a></span>i2c_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.finish from i2c_t3. </p>
<p>Any error is recorded in the recent error history variable. </p>

</div>
</div>
<a id="a864269a8f95ea93bc6e69e4d1b28a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864269a8f95ea93bc6e69e4d1b28a3ef">&#9670;&nbsp;</a></span>i2c_get_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Devices::I2CDEVICE_V1::I2CDevice::i2c_get_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current value of i2c_timeout in milliseconds. </p>
<dl class="section return"><dt>Returns</dt><dd>current i2c_timeout in milliseconds. </dd></dl>

</div>
</div>
<a id="ac1aae538360ead45a66e08792350b03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aae538360ead45a66e08792350b03a">&#9670;&nbsp;</a></span>i2c_peek_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Devices::I2CDEVICE_V1::I2CDevice::i2c_peek_errors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identical functionality to pop_errors except the recent error history variable isn't reset and the consecutive communication failure variable isn't incrememnted. </p>
<dl class="section return"><dt>Returns</dt><dd>true if an error has occurred since the last call to pop_errors and false otherwise. </dd></dl>

</div>
</div>
<a id="a1eb5d89d5d6e8a27f1b63b8a8fdd285c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb5d89d5d6e8a27f1b63b8a8fdd285c">&#9670;&nbsp;</a></span>i2c_ping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Devices::I2CDevice::i2c_ping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a simple communication with the i2c device - e.g. reading a register with a known value. Returns true if the proper value is recieved. i2c related errors are queried in setup. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the proper value was read and false otherwise </dd></dl>

<p>Reimplemented in <a class="el" href="class_a_d_s1015.html#a14b95bf3e49dff492f436e09756654cf">ADS1015</a>.</p>

</div>
</div>
<a id="aa2864b2e90683c0ae9384219ab457090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2864b2e90683c0ae9384219ab457090">&#9670;&nbsp;</a></span>i2c_pop_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Devices::I2CDEVICE_V1::I2CDevice::i2c_pop_errors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if an error has occurred since the last call to pop_errors and false otherwise. The recent error history variable is reset and the consecutive communication failure variables is incremented if needed. </p>
<dl class="section return"><dt>Returns</dt><dd>true if an error has occurred since the last call to pop_errors and false otherwise. </dd></dl>

</div>
</div>
<a id="aad5fb9b7c3eb25d9e009895814618f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5fb9b7c3eb25d9e009895814618f81">&#9670;&nbsp;</a></span>i2c_read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Devices::I2CDEVICE_V1::I2CDevice::i2c_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See Wire.readByte in i2c_t3. Any error will be recorded in the recent error history variable. </p>
<dl class="section return"><dt>Returns</dt><dd>next uint8_t in the incoming i2c buffer. Inlined call to Wire.readByte from i2c_t3. </dd>
<dd>
next uint8_t in the incoming i2c buffer.</dd></dl>
<p>Any error is recorded in the recent error history variable. Be sure to check for data integrity with a call to i2c_data_is_valid. </p>

</div>
</div>
<a id="afa55cfbcb2fa942d58c46995218709b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa55cfbcb2fa942d58c46995218709b7">&#9670;&nbsp;</a></span>i2c_read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDevice::i2c_read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data type tmeplated inlined call to Wire.read from i2c_t3. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data read from the i2c incoming buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data array to be written to from the i2c incoming buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements to be written over in the data array.</td></tr>
  </table>
  </dd>
</dl>
<p>Fills an array of arbitrary data type with data read from the incoming i2c buffer. Any error is recorded in the recent error history variable. Be sure to check for data integrity with a call to i2c_data_is_valid. </p>

</div>
</div>
<a id="aed45e8e4066e779b51b78d7ea0d51430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed45e8e4066e779b51b78d7ea0d51430">&#9670;&nbsp;</a></span>i2c_receive_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDevice::i2c_receive_data </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests and recieves a message over i2c from this i2c device. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data read form the incoming i2c buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Data buffer data will be written into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data buffer to be overwritten. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>This performs a series of blocking i2c commands to request data from this i2c device, read it into the the supplied data buffer, and update the recent error history variable. Be sure to check for data integrity with a call to i2c_data_is_valid. </p>

</div>
</div>
<a id="aa7018b892a9075c3e5994634f8775f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7018b892a9075c3e5994634f8775f71">&#9670;&nbsp;</a></span>i2c_request_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_request_from </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.requestFrom in i2c_t3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of message in bytes requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>The requested length, i2c stop flag, i2c device address, and i2c device timeout are all passed to the call to Wire.requestFrom. If the proper number of bytes is not recieved, an error is recorded in the recent error history variable. </p>

</div>
</div>
<a id="ab4e1fa9d03718b04326c6fe32a2340d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e1fa9d03718b04326c6fe32a2340d9">&#9670;&nbsp;</a></span>i2c_send_request()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_send_request </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See Wire.sendRequest in i2c_t3. Any error will be recorded in the recent error history variable. </p>
<p>Inlined call to Wire.sendRequest from i2c_t3. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of message in bytes requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>The requested length, i2c stop flag, and i2c device address are all passed to the call to Wire.sendRequest. The i2c device's timeout is not because this call is non-blocking. </p>

</div>
</div>
<a id="ae995510c34057de5825240532e3056cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae995510c34057de5825240532e3056cc">&#9670;&nbsp;</a></span>i2c_send_transmission()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_send_transmission </td>
          <td>(</td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inlined call to Wire.sendTransmission from i2c_t3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>Only the i2c stop flag is passed to the call to Wire.sendTransmission given it is a non-blocking call. </p>

</div>
</div>
<a id="a5b5c39d6bdfcd2137cd8a1acd5db9da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5c39d6bdfcd2137cd8a1acd5db9da2">&#9670;&nbsp;</a></span>i2c_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_set_timeout </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i2c_timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this device's i2c timeout in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_timeout</td><td>New i2c timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1c53f774f00a69a7619a6c095e5ffb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c53f774f00a69a7619a6c095e5ffb0">&#9670;&nbsp;</a></span>i2c_transmit_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDevice::i2c_transmit_data </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i2c_stop&#160;</td>
          <td class="paramname"><em>s</em> = <code>I2C_STOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message over i2c to this i2c device. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>of data written to the outgoing i2c buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written to the outgoing i2c buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements to be written from data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Sets whether or not an i2c stop signal is sent at the end of the transmission.</td></tr>
  </table>
  </dd>
</dl>
<p>This performs a series of blocking i2c commands to send data to this i2c device. Any error is recorded in the recent error history variable. </p>

</div>
</div>
<a id="acab012e2a96de88a49060fdf33c01706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab012e2a96de88a49060fdf33c01706">&#9670;&nbsp;</a></span>i2c_write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDEVICE_V1::I2CDevice::i2c_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See Wire.write in i2c_t3. Any error will be recorded in the recent error history variable. </p>
<p>Inline call to Wire.write from i2c_t3.</p>
<p>Writes a single byte to the outgoing i2c buffer. Any error is recorded in the recent error history variable. </p>

</div>
</div>
<a id="acc0c0dec51d0a4e584adaecadd69b2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0c0dec51d0a4e584adaecadd69b2fd">&#9670;&nbsp;</a></span>i2c_write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Devices::I2CDevice::i2c_write </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data type templated inlined call to Wire.write from i2c_t3. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data written to the i2c outgoing buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data array to be written to the i2c outgoing buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data array.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes an array of arbitrary data types to the outgoing i2c buffer. Any error is recorded in the recent error history variable. </p>

</div>
</div>
<a id="a15eb87401c706fe75b7c8c4ad5154b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb87401c706fe75b7c8c4ad5154b69">&#9670;&nbsp;</a></span>is_functional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CDevice::is_functional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies the device is responding to communications. </p>
<dl class="section return"><dt>Returns</dt><dd>True if device is responding to communications, false otherwise.</dd></dl>
<p>This functions simply returns whether or not the current device should be treated as functional. A device may be marked not functional for two reasons:</p><ol type="1">
<li>The device was disabled by a call to the disable function.</li>
<li>The device marked itself as not functional do to multiple, consecutive communication failures. Communication with the device should not be attempted if it is marked as not functional. </li>
</ol>

<p>Implements <a class="el" href="class_devices_1_1_device.html#a2381511533b5322f58a7cf8b9c677416">Devices::Device</a>.</p>

</div>
</div>
<a id="a73f49c62499886a4b46b9865f9469be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f49c62499886a4b46b9865f9469be7">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void I2CDevice::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces this i2c device to be marked as functional. </p>
<p>The error history variable is reset which therefore marks the device as functional. The device will still mark itself as not functional if it has I2CDEVICE_DISABLE_AT i2c errors in a row. </p>

<p>Implements <a class="el" href="class_devices_1_1_device.html#abc9efccf9498c925e5d2ab3e198e81f1">Devices::Device</a>.</p>

<p>Reimplemented in <a class="el" href="class_devices_1_1_gomspace.html#a45d210d8673007c4bb98fcbefcea9e4e">Devices::Gomspace</a>.</p>

</div>
</div>
<a id="a3798b32d253b3e30f75e648d7b390a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3798b32d253b3e30f75e648d7b390a49">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CDevice::setup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to initialize communication with the i2c device. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the setup was succesful and false otherwise.</dd></dl>
<p>The function makes up to I2CDEVICE_DISABLE_AT calls to the i2c_ping function. If any of those calls returns true, the setup function is considered to succesful. If the setup function returns false, this implies the device is not functional and is marked as such. </p>

<p>Implements <a class="el" href="class_devices_1_1_device.html#a58eef2ff2cf3c62c8033af034c0c841f">Devices::Device</a>.</p>

<p>Reimplemented in <a class="el" href="class_devices_1_1_gomspace.html#a38f9c4a86dc09658b78e2c0e9956c84c">Devices::Gomspace</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/Devices/<a class="el" href="_i2_c_device_8hpp_source.html">I2CDevice.hpp</a></li>
<li>lib/Devices/I2CDevice.cpp</li>
<li>lib/Devices/I2CDevice.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
